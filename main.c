#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "includes/algorithms.h"
#include "includes/utils.h"

void (*algorithm)(long long*, long long, short) = NULL; // variable for storing pointer to sorting function
FILE* file = NULL; // variable for file handling
char* file_name = NULL; // string for storing opening file name
clock_t* shell_times = NULL; // array with clock values for benchmark shell sorting
clock_t* insert_times = NULL; // array with clock values for benchmark insertion sorting
clock_t* insert_s_times = NULL; // array with clock values for benchmark slow insertion sorting
long long file_size = 0; // variable with count of integer read from file
short multiplier = 1; // variable-modificator for reverse/non-reverse sorting
long long ra_size = 0; // variable with size of array with random integers for just-gen option
short benchmark_mode = 0; // variable that sets benchmark program mode
long long* dataset = NULL; // array with sizes of arrays to test in benchmark
long long dataset_size = 0; // variable-size of dataset array
unsigned long long max_random = RAND_MAX; // variable for defining max random generated integer


int main(int argc, char** argv) {

	srand(time(0));

	for (int i = 1; i < argc; i++) {

		if (!strcmp(argv[i], "-a") || !strcmp(argv[i], "--algorithm")) { // check is next arg possible algorithm and make variable for it

			if ((i + 1) < argc && (algorithm = return_algo(argv[i + 1])))
				i++;

			else {

				printf("Parameter after %s should be a valid algorithm. For exmaples check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-b") || !strcmp(argv[i], "--benchmark")) { // set benchmark mode and sizes of arrays for him

			benchmark_mode = 1;

			dataset = (long long*)malloc(sizeof(long long));

			while ((i + dataset_size + 1) < argc && return_num(argv[i + dataset_size + 1], strlen(argv[i + dataset_size + 1]))) {

				dataset[dataset_size] = return_num(argv[i + dataset_size + 1], strlen(argv[i + dataset_size + 1]));
				dataset_size++;
				dataset = (long long*)realloc(dataset, sizeof(long long) * (dataset_size + 1));
			}

			if (dataset_size == 0) {

				printf("You must specify at least 1 not null number after %s parameter.\n", argv[i]);
				return 0;
			}

			else
				i += dataset_size;

		}

		else if (!strcmp(argv[i], "-f") || !strcmp(argv[i], "--file")) { // check is next arg an existing file

			if ((i + 1) < argc)
				file_name = argv[++i];

			else {

				printf("Parameter after %s should be a valid filename. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")) { // help option

			printf("Manual for sorting program.\n");
			printf("Usage options:\n");
			printf("\t-a, --algorithm [ shell_sort, shellsort, shell, insertion_sort, insertionsort, insertion ] \t set sorting algorithm\n");
			printf("\t-b, --benchmark [ N1, N2, N3, ... ] \t set benchmark mode. Should be used with numbers after parameter, numbers sets sizes of arrays for testing.\n");
			printf("\t-f, --file [ filename ] \t setting name of file with numbers that will be sorted. Program puts sorted integers in this file\n");
			printf("\t-m, --max-num [ N ] \t setting max number that can be generated by a program\n");
			printf("\t-n, --no-sort [ N ] \t generate file with random integers without sorting. After paramater should given number with count of integers in file\n");
			printf("\t-r, --reverse \t setting reverse sorting mode\n");
			printf("\t-h, --help \t display this manual\n");

			return 0;
		}

		else if (!strcmp(argv[i], "-m") || !strcmp(argv[i], "--max-num")) { // set maximum random generated number, default is RAND_MAX constant

			if ((i + 1) < argc && return_num(argv[i + 1], strlen(argv[i + 1])) && return_num(argv[i + 1], strlen(argv[i + 1])) > 0) {
			
				max_random = return_num(argv[i + 1], strlen(argv[i + 1])) + 1;
				i++;
			}

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-n") || !strcmp(argv[i], "--no-sort")) {	// generate file with random numbers without sorting

			if ((i + 1) < argc && (ra_size = return_num(argv[i + 1], strlen(argv[i + 1]))))				
				i++;

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-r") || !strcmp(argv[i], "--reverse")) // set reverse flag
			multiplier = -1;

		else { // unknown option, exiting

			printf("Unknown option, use --help for more information.\n");
			return 0;
		}
	}


	if (ra_size) {

		file_name = file_name ? file_name : "output.txt";
		file = fopen(file_name, "w+");

		if (!file)
			printf("Unable to open/create file.\n");
		
		else {

			get_random_file(file, ra_size, max_random);
			fclose(file);
		}

		return 0;
	}

	if (benchmark_mode) {

		if (dataset_size >= 1 && check_dataset(dataset, dataset_size)) {

			shell_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);
			insert_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);
			insert_s_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);

			long long* arr_shell;
			long long* arr_insert;
			long long* arr_insert_s;

			for (long long i = 0; i < dataset_size; i++) {

				arr_shell = get_random_array(dataset[i], max_random);
				arr_insert = get_random_array(dataset[i], max_random);
				arr_insert_s = get_random_array(dataset[i], max_random);

				shell_times[i] = benchmark(arr_shell, dataset[i], shell_sort, multiplier);
				insert_times[i] = benchmark(arr_insert, dataset[i], insertion_sort, multiplier);
				insert_s_times[i] = benchmark(arr_insert_s, dataset[i], insertion_sort_slow, multiplier);

				free(arr_shell);
				free(arr_insert);
				free(arr_insert_s);
			}


			printf("\n\n========RESULTS FOR SHELL SORT=========\n\n");

			for (long long k = 0; k < dataset_size; k++)
				printf("Array size: %lld, clocks: %ld, seconds: %Lf\n", dataset[k], shell_times[k], (long double)shell_times[k] / (long double)CLOCKS_PER_SEC);

			printf("\n=======================================\n");

			printf("\n\n========RESULTS FOR INSERTION SORT=========\n\n");

			for (long long k = 0; k < dataset_size; k++)
				printf("Array size: %lld, clocks: %ld, seconds: %Lf\n", dataset[k], insert_times[k], (long double)insert_times[k] / (long double)CLOCKS_PER_SEC);

			printf("\n===========================================\n\n");

			printf("\n\n========RESULTS FOR SLOW INSERTION SORT=========\n\n");

			for (long long k = 0; k < dataset_size; k++)
				printf("Array size: %lld, clocks: %ld, seconds: %Lf\n", dataset[k], insert_s_times[k], (long double)insert_s_times[k] / (long double)CLOCKS_PER_SEC);

			printf("\n================================================\n\n\n");
		}

		else
			printf("You must specify some not null numbers after benchmark parameter.\n");
		
		return 0;
	}

	if (file_name) {

		if (!algorithm)
			algorithm = (rand() % 2) ? shell_sort : insertion_sort;

		file = fopen(file_name, "r+");

		if (!file)
			printf("File doesn\'t exist or can\'t be opened.\n");

		else {

			long long file_size = 0;
			long long* arr = read_file(file, &file_size);

			algorithm(arr, file_size, multiplier);

			freopen(file_name, "w", file);
			write_file(file, arr, file_size);
			fclose(file);

			free(arr);
		}

		return 0;
	}

	return 0;
}