#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "includes/algorithms.h"
#include "includes/benchmark.h"
#include "includes/utils.h"

extern unsigned long long MAX_RAND;
extern short multiplier;
extern char* file_name;
extern void (*alg_fs[ALGO_COUNT])(int*, int);
extern short benchmark_mode;
extern int* dataset;
extern int* random_arr;
extern FILE* file;
extern void (*algorithm)(int*, int);
extern int dataset_size;
extern int ra_size;
extern clock_t* shell_times;
extern clock_t* insert_times;


int main(int argc, char** argv) {

	alg_fs[0] = shell_sort;
	alg_fs[1] = insertion_sort;

	multiplier = 1;
	benchmark_mode = 0;
	MAX_RAND = RAND_MAX;
	ra_size = 0;
	file_name = NULL;

	for (int i = 1; i < argc; i++) {

		//printf("i = %d: %s\n", i, argv[i]);

		if (!strcmp(argv[i], "-a") || !strcmp(argv[i], "--algorithm")) {

			// check is next arg possible algorithm and make variable for it
			if ((i + 1) <= argc && (algorithm = return_algo(argv[i + 1]))) {

				i++;
			}

			else {

				printf("Parameter after %s should be a valid algorithm. For exmaples check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-b") || !strcmp(argv[i], "--benchmark")) {

			benchmark_mode = 1;
		}

		else if (!strcmp(argv[i], "--dataset")) {

			// set dataset for benchmark

			dataset_size = 1;

			dataset = (int*)malloc(sizeof(int));

			while ((i + dataset_size) < argc && return_num(argv[i + dataset_size], strlen(argv[i + dataset_size]))) {

				dataset[dataset_size - 1] = return_num(argv[i + dataset_size], strlen(argv[i + dataset_size]));
				dataset = (int*)realloc(dataset, ++dataset_size);
			}

			if (dataset_size == 1) {

				printf("You must specify at least 1 not nil number after %s parameter.\n", argv[i]);
				return 0;
			}

			else {

				i += --dataset_size;
			}

		}

		else if (!strcmp(argv[i], "-f") || !strcmp(argv[i], "--file")) {

			// check is next arg an existing file

			if ((i + 1) <= argc) {

				file_name = argv[i + 1];
				file = fopen(file_name, "r+");

				if (!file && !ra_size) {

					printf("File with provided filename doesn\'t exist or can\'t be opened.\n");
					return 0;
				}

				i++;

				// call a function from fhandle.c to read from file
			}

			else {

				printf("Parameter after %s should be a valid filename. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")) {

			// help option

			printf("Manual for sorting program.\n");
			printf("Usage options:\n");
			printf("\t-a, --algorithm [ shell_sort, shellsort, shell, insertion_sort, insertionsort, insertion ] - parameter used for setting sorting algorithm.\n");
			printf("\t-b, --benchmark - parameter setting benchmark program mode. Should be used with --dataset parameter to set count of numbers being generated and sorted.\n");
			printf("\t\tProgram will be tested with all available algorithms.\n");
			printf("\t--dataset [ N1, N2, ... ] - used for setting count of integers will be generated to make a benchmark. Will be generated N1 integers for first test, N2 integers for second test etc.\n");
			printf("\t-f, --file [ filename ] - setting name of file with numbers that will be sorted. Program puts sorted integers in this file.\n");
			printf("\t-m, --max-num [ N ] - setting max number that can be generated by a program.\n");
			printf("\t-n, --no-sort [ N ] - with this parameter program will generate file with integers, but will not sort it. Should be used with one value - number of integers in new file.\n");
			printf("\t-r, --reverse - setting reverse sorting mode.\n");
			printf("\t-h, --help - display this manual.\n");

			return 0;
		}

		else if (!strcmp(argv[i], "-m") || !strcmp(argv[i], "--max-num")) {

			// set maximum random generated number, default is RAND_MAX constant = 2147483647

			if ((i + 1) <= argc && return_num(argv[i + 1], strlen(argv[i + 1]))) {

				MAX_RAND = return_num(argv[i + 1], strlen(argv[i + 1]));

				if (!return_num(argv[i + 1], strlen(argv[i + 1]))) {

					printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
					return 0;
				}

				i++;
			}

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-n") || !strcmp(argv[i], "--no-sort")) {

			// generate file with random numbers without sorting

			if ((i + 1) <= argc && (ra_size = return_num(argv[i + 1], strlen(argv[i + 1])))) {
				
				random_arr = get_random_array(ra_size);
				i++;
			}

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-r") || !strcmp(argv[i], "--reverse")) {

			// set reverse flag
			multiplier = -1;
		}

		else {

			printf("Unknown option, use --help for more information.\n");
			return 0;
		}
	}


	printf("\n==============================\n");
	dump_all();
	printf("\n==============================\n");


	if (ra_size) {

		if (file_name)
			get_random_file(ra_size, file_name);
		else
			get_random_file(ra_size, "output.txt");

		return 0;
	}

	if (benchmark_mode) {

		if (dataset_size > 1 && check_dataset()) {

			shell_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);
			insert_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);

			int* arr_shell;
			int* arr_insert;

			for (int i = 0; i < dataset_size; i++) {

				arr_shell = get_random_array(dataset[i]);
				arr_insert = get_random_array(dataset[i]);

				shell_times[i] = benchmark(arr_shell, dataset[i], alg_fs[SHELL_SORT]);
				insert_times[i] = benchmark(arr_insert, dataset[i], alg_fs[INSERTION_SORT]);

			}

			// TODO output results of benchmark

		}

		else
			printf("You must specify only not nil numbers after --dataset parameter.\n");
		
		return 0;
	}

	// TODO standart file sorting


	return 0;
}