#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "includes/algorithms.h"
#include "includes/utils.h"

void (*algorithm)(long long*, long long, short) = NULL;
FILE* file = NULL;
long long* random_arr = NULL;
char* file_name = NULL;
clock_t* shell_times = NULL;
clock_t* insert_times = NULL;
long long file_size = 0;
short multiplier = 1;
long long ra_size = 0;
short benchmark_mode = 0;
long long* dataset = NULL;
long long dataset_size = 0;
unsigned long long MAX_RAND = RAND_MAX; // variable for defining max random generated integer


int main(int argc, char** argv) {

	srand(time(0));

	for (int i = 1; i < argc; i++) {

		//printf("i = %d: %s\n", i, argv[i]);

		if (!strcmp(argv[i], "-a") || !strcmp(argv[i], "--algorithm")) { // check is next arg possible algorithm and make variable for it

			if ((i + 1) < argc && (algorithm = return_algo(argv[i + 1])))
				i++;

			else {

				printf("Parameter after %s should be a valid algorithm. For exmaples check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-b") || !strcmp(argv[i], "--benchmark")) // set benchmark mode
			benchmark_mode = 1;

		else if (!strcmp(argv[i], "--dataset")) { // set dataset for benchmark

			dataset = (long long*)malloc(sizeof(long long));

			while ((i + dataset_size + 1) < argc && return_num(argv[i + dataset_size + 1], strlen(argv[i + dataset_size + 1]))) {

				dataset[dataset_size] = return_num(argv[i + dataset_size + 1], strlen(argv[i + dataset_size + 1]));
				dataset_size++;
				dataset = (long long*)realloc(dataset, sizeof(long long) * (dataset_size + 1));
			}

			if (dataset_size == 0) {

				printf("You must specify at least 1 not null number after %s parameter.\n", argv[i]);
				return 0;
			}

			else
				i += dataset_size;

		}

		else if (!strcmp(argv[i], "-f") || !strcmp(argv[i], "--file")) { // check is next arg an existing file

			if ((i + 1) < argc)
				file_name = argv[++i];

			else {

				printf("Parameter after %s should be a valid filename. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")) { // help option

			printf("Manual for sorting program.\n");
			printf("Usage options:\n");
			printf("\t-a, --algorithm [ shell_sort, shellsort, shell, insertion_sort, insertionsort, insertion ] \t set sorting algorithm\n");
			printf("\t-b, --benchmark \t set benchmark mode. Should be used with --dataset parameter\n");
			printf("\t--dataset [ N1, N2, ... ] \t setting count of integers will be generated to make a benchmark. Will be generated N1 integers for first test, N2 integers for second test etc\n");
			printf("\t-f, --file [ filename ] \t setting name of file with numbers that will be sorted. Program puts sorted integers in this file\n");
			printf("\t-m, --max-num [ N ] \t setting max number that can be generated by a program\n");
			printf("\t-n, --no-sort [ N ] \t generate file with random integers without sorting. After paramater should given number with count of integers in file\n");
			printf("\t-r, --reverse \t setting reverse sorting mode\n");
			printf("\t-h, --help \t display this manual\n");

			return 0;
		}

		else if (!strcmp(argv[i], "-m") || !strcmp(argv[i], "--max-num")) { // set maximum random generated number, default is RAND_MAX constant

			if ((i + 1) < argc && return_num(argv[i + 1], strlen(argv[i + 1])) && return_num(argv[i + 1], strlen(argv[i + 1])) > 0) {
			
				MAX_RAND = return_num(argv[i + 1], strlen(argv[i + 1])) + 1;
				i++;
			}

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}

		}

		else if (!strcmp(argv[i], "-n") || !strcmp(argv[i], "--no-sort")) {	// generate file with random numbers without sorting

			if ((i + 1) < argc && (ra_size = return_num(argv[i + 1], strlen(argv[i + 1]))))				
				i++;

			else {

				printf("Parameter after %s should be a valid number. For more information check --help.\n", argv[i]);
				return 0;
			}
		}

		else if (!strcmp(argv[i], "-r") || !strcmp(argv[i], "--reverse")) // set reverse flag
			multiplier = -1;

		else { // unknown option, exiting

			printf("Unknown option, use --help for more information.\n");
			return 0;
		}
	}


	if (ra_size) {

		file_name = file_name ? file_name : "output.txt";
		file = fopen(file_name, "w+");

		if (!file)
			printf("Unable to open/create file.\n");
		
		else {

			get_random_file(file, ra_size, MAX_RAND);
			fclose(file);
		}

		return 0;
	}

	if (benchmark_mode) {

		if (dataset_size >= 1 && check_dataset(dataset, dataset_size)) {

			shell_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);
			insert_times = (clock_t*)malloc(sizeof(clock_t) * dataset_size);

			long long* arr_shell;
			long long* arr_insert;

			for (long long i = 0; i < dataset_size; i++) {

				arr_shell = get_random_array(dataset[i], MAX_RAND);
				arr_insert = get_random_array(dataset[i], MAX_RAND);

				shell_times[i] = benchmark(arr_shell, dataset[i], shell_sort, multiplier);
				insert_times[i] = benchmark(arr_insert, dataset[i], insertion_sort, multiplier);

				free(arr_shell);
				free(arr_insert);
			}


			printf("\n\n========RESULTS FOR SHELL SORT=========\n\n");

			for (long long k = 0; k < dataset_size; k++) {

				printf("Array size: %lld, clocks: %ld, seconds: %ld\n", dataset[k], shell_times[k], shell_times[k] / CLOCKS_PER_SEC);

			}

			printf("\n=======================================\n");

			printf("\n\n========RESULTS FOR INSERTION SORT=========\n\n");

			for (long long k = 0; k < dataset_size; k++) {

				printf("Array size: %lld, clocks: %ld, seconds: %ld\n", dataset[k], insert_times[k], insert_times[k] / CLOCKS_PER_SEC);

			}

			printf("\n===========================================\n\n\n");

			free(shell_times);
			free(insert_times);

			free(dataset);
		}

		else
			printf("You must specify --dataset parameter without null numbers.\n");
		
		return 0;
	}

	if (file_name) {

		if (!algorithm)
			algorithm = (rand() % 2) ? shell_sort : insertion_sort;

		file = fopen(file_name, "r+");

		if (!file)
			printf("File doesn\'t exist or can\'t be opened.\n");

		else {

			long long file_size = 0;
			long long* arr = read_file(file, &file_size);

			algorithm(arr, file_size, multiplier);

			freopen(file_name, "w", file);

			write_file(file, arr, file_size);

			fclose(file);
		}

		return 0;
	}

	return 0;
}